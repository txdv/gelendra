#!/usr/bin/ruby
require 'yaml'
require 'rubygems'
require 'zip/zip'
require 'etc'
require 'fileutils'

# TODO: Manage occurences in different archives (ALLOW THEM!)
# TODO: Check if the files in the archives are all in small letters
# TODO: Support different archives, create OOP archive control
# TODO: Directive to copy all files logged in database to another directory
# TODO: Remove // from copy messages
# TODO: List archives in alphabetic order
# TODO: Add help

BASEINFO = "#{Etc.getpwuid.dir}/.gelendra.yaml"
class BaseInfo
  
  def initialize
    File.open(BASEINFO, "a+") do |f|
      @data = YAML::load(f.read)
      @data = {"base_dir"=>[]} if @data == false
    end
  end

  def base_dir
    @data["base_dir"]
  end

  def save
    File.open(BASEINFO, "w") { |f| f.puts @data.to_yaml }
  end

  def get_packages(pattern)
    pkg = []
    base_dir.each do |dir|
      pkg.concat Dir["#{dir}/#{pattern}"]
    end
    return pkg
  end

end

class Cli
  public
  def initialize(baseinfo, localinfo)
    @baseinfo = baseinfo
    @localinfo = localinfo
    @pm = PackageManager.new(localinfo)
    # @localinfo = localinfo
    #@manager = manager
  end

  def zip_rebase
    @pm.rebase
  end

  def zip_check

  end

  def package_install(name)
    @baseinfo.get_packages(name).each do |name| 
      begin
        puts
        puts "Installing #{name}"
        @pm.install(name)
      rescue => msg
        puts "\tError during installation: #{msg}"
      end
    end
  end

  def package_remove(name)
    # TODO: THIS IS A BAD HACK, PLEASE REMAKE WITH HIDDEN DIR AND EMPTY FILES
    # Which obviously is a hack too, but better then writing own parser ...
    list = @baseinfo.get_packages(name).reject { |e| !@localinfo.exists?(File.basename(e)) }
    list.collect! { |fullname| File.basename(fullname) }

    list.each do |package|
      begin
        puts
        puts "Removing #{package}"
        @pm.remove(package)
      rescue => msg
        puts "Error during removing: #{msg}"
      end
    end
  end

  def package_available(name = "*")
    puts @baseinfo.get_packages(name)
  end

  def package_list(name = "*")
    # TODO: SAME HACK, REMOVE PLEASE
    list = @baseinfo.get_packages(name).reject { |e| !@localinfo.exists?(File.basename(e)) }
    list.collect! { |fullname| File.basename(fullname) }
    puts list
  end

  def basedir_add(dir)
    if File.directory?(dir)
      dir = File.expand_path(dir)
      if !@baseinfo.base_dir.include?(dir)
        @baseinfo.base_dir.push File.expand_path(dir)
        @baseinfo.save
      else
        puts "Directory already in basedir path: #{dir}"
      end
    else
      puts "No such directory: #{dir}"
    end
  end

  def basedir_rem(dir)
    dir = File.expand_path(dir)
    
    if @baseinfo.base_dir.include?(dir)
      @baseinfo.base_dir.delete(dir)
      @baseinfo.save
      puts "basedir removed: #{dir}"
    else
      puts "No such directory in database: #{dir}"
    end
  end

  def basedir_list
    puts "Base directories remembered:\n"
    puts
    puts @baseinfo.base_dir
    puts
  end

  def list_packages(name = "*")
    package_list(name)
  end

  def list_files
    puts @localinfo.all_files
  end

  def list_archives
    puts @localinfo.archives
  end

  def list_allmaps
    puts mapify(allmaps)
  end

  def list_installedmaps
    puts mapify(allmaps.reject { |m| !@localinfo.all_files.include?(m)})
  end

  def list_basemaps    
    puts mapify(allmaps.reject { |m| @localinfo.all_files.include?(m)})
  end

  def help
    puts <<HELPSTRING
  gelendra v0.1
  
  install <archive>
    extracts archive in the current directory and puts all the data to the local database
  remove <archive>
    removes the extracted archive files

  basedir add <directory>
    remembers a directory, where it will look for packages

  basedir rem
    removes a basedir <directory>
HELPSTRING
  end

  private
   
  def mapify(maps)
    maps.collect do |i|
      f = File.basename(i) 
      f = f.split(".")
      f.pop
      f = f.join(".")
      f
    end
  end

  def allmaps
    Dir["cstrike/maps/*.bsp"]
  end

end

class CliInvoker
  public
  def initialize(klass)
    @klass = klass
    @methods = klass.public_methods - Class.public_methods
  end

  def run(args)
    name = []
    
    methods = @methods

    x = 0
    while (methods.size > 1)
      methods = collect_start(methods, ARGV[x])
      methods = trunc(methods, ARGV[x].to_s)
      name.push ARGV[x]
      
      if (methods.size == 1)
        funcname = name.join("_")
        arguments = ARGV[x+1..9999].join(" ")

        if arguments.size == 0
          evalstr = "@klass.#{funcname}"
      
        else
          evalstr = "@klass.#{funcname}(#{arguments.inspect})"
        end
        # puts evalstr
        # puts
        eval(evalstr)
        return
      end
      x += 1
    end
  end

  private 
  def trunc(methods, arg)
    methods.collect { |name| name.split("_")[1...9999].join("_") }
  end

  def starts_with(fullname, startstr)
    fullname.split("_").first == startstr
  end
  
  def collect_start(methods, startstr)
    methods.reject { |func| !starts_with(func, startstr) }
  end
end

class LocalInfo
  def initialize(file = 'database.yaml')
    begin

      File.open(file,"a+") { |f| @data = YAML::load(f.read) }
    rescue
      @data = { :zipfile=> nil, :installed => { } } 
    end
    @data = { :zipfile=> nil, :installed => { } } if @data == false
  end

  def zipfile
    @data[:zipfile]
  end

  def add(archivename, list)
    @data[:installed][archivename] = list
  end

  def delete(archive)
    @data[:installed].delete(archive)
  end

  def exists?(archive)
    !@data[:installed][archive].nil?
  end

  def save(file = 'database.yaml')
     File.open(file,"w") { |f| f.puts @data.to_yaml }
  end

  def occurs(file)
    @data[:installed].each do |key,val| 
      return true if val.include?(file) 
    end
    return false
  end

  def archives
    archs = []
    @data[:installed].each { |key,val| archs.push(key) }
    return archs
  end

  def files(archive)
    @data[:installed][archive]
  end

  def all_files
    all = []
    archives.each { |arch| all.concat(files(arch)) }
    return all
  end
end

class PackageManager
  def initialize(localinfo)
    @localinfo = localinfo
  end

  def remove(package)

    filelist =  @localinfo.files(package)
    filelist.each do |file| 
      puts "\tremoving #{file}"
      if (!File.directory?(file))
        FileUtils.rm file
      end
    end
    @localinfo.delete(package)
    @localinfo.save
    
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      filelist.each do |file| 
        puts "\tremoving #{file} from #{@localinfo.zipfile}"
        outputfile.remove(file)
      end
    end
    end
  end

  def install(filefullpath)
    filename = File.basename(filefullpath)
    raise "Package #{filename} already installed!" if @localinfo.exists?(filename)

    filelist = nil
    Zip::ZipFile.open(filefullpath) { |package| 
      # filelist = package.entries.collect { |x| x.name }
      filelist = package.entries.reject { |e| e.directory? }.collect { |x| x.name }.sort
      @localinfo.add(filename, filelist)

      # create all directories if not existend
      filelist.each { |entry| get_directories(entry).each { |dir| install_dir dir } }
      
      # TODO: sort entry names
      package.entries.each do |entry|
        if !entry.directory?
          puts "\textracting file #{entry.name}" 
          entry.extract
        end
      end
    }
    @localinfo.save

    # modify the giant zip file

    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile| 
      filelist.each do |name|
        puts "\tadding #{name} to #{@localinfo.zipfile}"
        if outputfile.find_entry(name).nil?
          outputfile.add(name, name)
        else
        puts "\tWARNING: file #{name} in #{@localinfo.zipfile} already exists"
        end
      end
    end
    end
  end

  def one_less(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir[0..file_or_dir.size-base.size-2]
  end
  def one_less?(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir.size-base.size-2 > 0
  end

  def get_directories(file)
    filename = File.basename(file)
    dirname = one_less(file)

    dirs = [dirname]

    while (one_less?(dirname))
      dirname = one_less(dirname)
      dirs.push dirname
    end
    
    return dirs.sort
  end

  def install_dir(dir)
    FileUtils.mkdir(dir) if !File.directory?(dir)
  end
  
  def dir_empty(dir)
    Dir.entries(dir).join == "..."
  end

  def rebase
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      @localinfo.all_files.each do |file|
        if outputfile.find_entry(file).nil?
          puts "#{@localinfo.zipfile}: missing and adding #{file}"
          outputfile.add(file, file)
        end
        outputfile.commit # makes it more interactive
      end
    end
    end
  end

  def zipfile 
    return Zip::ZipFile.open(@localinfo.zipfile, "wb")
  end

end



if !File.exists?('database.yaml')
  puts "Not under gelendra control, please initialize"
  # exit
end

baseinfo = BaseInfo.new
localinfo = LocalInfo.new

=begin
Zip::ZipFile.open(localinfo.zipfile, "wb") do |file|
  file.get_output_stream("readme.txt") do |stream|
    stream.puts <<ENDOFTEXT
cs.six.lt mapai
ENDOFTEXT
  end
end
=end

cli = Cli.new(baseinfo, localinfo);
cliinvoker = CliInvoker.new(cli)
cliinvoker.run(ARGV)
