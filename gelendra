#!/usr/bin/ruby
=begin
    gelendra is a package(archive) manager for managing counterstrike 1.6 maps, addons, etc.
    Copyright (C) 2010  Andrius Bentkus

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
=end

require 'yaml'
require 'rubygems'
require 'zip/zip'
require 'etc'
require 'fileutils'

# Functionality:
# TODO: Check if the files in the archives are all in small letters
# TODO: Add a function to downcase all files in a archive file
# TODO: Support different archives, create OOP archive control
# TODO: Add function which copies all files logged in database to another directory
# TODO: Add database file softlinking
# TODO: Add package checking (read entities!) (check if this feature is complete)
# TODO: Add a package creator: you select a dir with files, it finds all bspmaps and
#       creates a lot of packages into a destination dir (only complete ofcourse)

# CliInvoker:
# TODO: Adjust CliInvoker to better work (let single command lines work)
# TODO: Add command line function help definition support in CliInvoker

# Misc:
# TODO: Add independent game architecture (list maps of other games, pick only public files)
# TODO: Manage occurences in different archives (ALLOW THEM! if files are equal)

class String
  def shift(char)
    tmp = self.split(char)
    tmp.shift
    return tmp.join(char)
  end
end

# quick fix to make zip files work with *seek*
class Zip::ZipInputStream
  # TODO: init local variable @seekpos in constructor
  def seek(pos)
    @seekpos = 0 if @seekpos.nil?
    raise "Operation not permited, seek in ZipInputStream works only one way, now at #{@seekpos} and trying to go to #{pos}" if (pos < @seekpos)
    read(pos - @seekpos)
    @seekpos = pos
    return
  end

  def read(size)
    ret = super(size)
    @seekpos += size
    return ret
  end

end

class BSP

  QUAKE_VALVE_GOLDSRC = 30
  BSP_HEADER_ENTITIES = 0
  BSP_HEADER_MIPTEX = 2

  def self.read_dentry
    @stream.read(8).unpack("II")
  end

  def self.read_uint
    # read an unsigned integer
    @stream.read(4).unpack("I")[0]
  end

  def self.read_string(size)
    @stream.read(size).unpack("Z*")[0]
  end
  
  def self.read_header
    @stream.seek(0)
    raise "This file is not a valve bsp map" if read_uint != QUAKE_VALVE_GOLDSRC
    @header = []
    15.times { @header.push read_dentry }
  end

  def self.read_mipheader
    @stream.seek(@header[BSP_HEADER_MIPTEX][0])
    @mip_offset = []
    read_uint.times { @mip_offset.push read_uint + @header[BSP_HEADER_MIPTEX][0] }
  end

  def self.read_mips
    textures = []
    @mip_offset.each do |startpos|
      @stream.seek(startpos)
      name = @stream.read(16).unpack("Z*")[0].downcase

      height, width, offset1, offset2, offset3, offset4 = @stream.read(6*4).unpack("L"*6)
      #p [height, width]
      #p [offset1, offset2, offset3, offset4]
      textures.push name if (offset1 == 0)
      #puts name

    end
    return textures
  end

  def self.read_entity_entries
    @stream.seek(@header[BSP_HEADER_ENTITIES][0])
    entities = read_string(@header[BSP_HEADER_ENTITIES][1])
    return EntityParser.get_files(EntityParser.parse(entities))
  end

  def self.get_info(stream)
    @stream = stream

    read_header
    wads, files = read_entity_entries
    read_mipheader
    textures = read_mips

    return wads, files, textures
  end

end

class EntityParser
  @sky_endings = [ "bk", "ft", "dn", "up" , "rt", "lf" ]
  def self.parse(text)
    entities = []
    entity = nil
    text.each_line do |line|
      case line.chop
      when "{"
        entity = {}
      when "}"
        entities.push(entity)
      when /"(.+|)" "(.+|)"/
        entity[$1] = $2
      else
      end
    end
    return entities
  end
  
  def self.get_files(entities)
    # TODO: find gibmodels

    # get the mdl's and sprites
    tmp = entities.collect { |entity| entity["model"] if entity.has_key?("model") }.uniq
    tmp.delete(nil)
    files = tmp.collect { |file| file if !(file =~ /\*\d+/) }.uniq
    files.delete(nil)

    if entities[0].has_key?("skyname")
      files += @sky_endings.collect { |ending| "gfx/env/" + entities[0]["skyname"] + ending + ".tga" }
    end

    wads = []
    if entities[0].has_key?("wad")
      wads = entities[0]["wad"].split(";").collect { |i| i.split("\\").last }
    end

    return [wads, files.sort!]
  end
end

class WAD
  def self.read_magic
    @stream.read(4).unpack("Z4")[0]
  end

  def self.read_integer
    # read an unsigned integer
    @stream.read(4).unpack("I")[0]
  end

  def self.get_entries(stream)
    @stream = stream
    @stream.seek(0)
    raise "The file supplied has no wad" if read_magic != "WAD3"
    numentries = read_integer
    offset = read_integer

    @stream.seek(offset)
    names = []
    numentries.times do
      names.push @stream.read(4 + 4 + 4 + 1 + 1 + 2 + 16).unpack("IIIccsZ*").last
    end
    return names
  end
end


class BaseInfo
  include Singleton

  BASEINFOFILE = "#{Etc.getpwuid.dir}/.gelendra.yaml"
  BASEFILES = "#{Etc.getpwuid.dir}/.basefiles.yaml"

  def initialize
    File.open(BASEINFOFILE, "a+") do |f|
      @data = YAML::load(f.read)
      @data = {"base_dir"=>[]} if @data == false
    end

    File.open(BASEFILES, "r") do |f|
      @basefiles = YAML::load(f.read)
    end
  end

  def base_dir
    @data["base_dir"]
  end

  def save
    File.open(BASEINFOFILE, "w") { |f| f.puts @data.to_yaml }
  end

  def get_packages(pattern = "*")
    pkg = []
    base_dir.each do |dir|
      pkg.concat Dir["#{dir}/#{pattern}"]
    end
    return pkg.sort
  end

  def include?(file)
    @basefiles[:files].each do |key,arr|
      return true if arr.include?(file)
    end
    return false
  end

  def wads
    @basefiles[:wads]
  end
  
end


class LocalInfo
  # TODO: Rewrite so it will open the file only if really needed (when data invoked)
  def initialize(baseinfo, file = 'database.yaml')
    @baseinfo = baseinfo
    begin
      File.open(file,"r") { |f| @data = YAML::load(f.read) }
    rescue
      @data = { :zipfile=> nil, :installed => { } } 
    end
    @data = { :zipfile=> nil, :installed => { } } if @data == false
  end

  def zipfile
    @data[:zipfile]
  end

  def add(archivename, list)
    @data[:installed][archivename] = list
  end

  def delete(archive, file = nil)
    if file.nil?
      @data[:installed].delete(archive)
    else
      @data[:installed][archive].delete(file)
    end
  end

  def exists?(archive)
    !@data[:installed][archive].nil?
  end

  def save(file = 'database.yaml')
     File.open(file,"w") { |f| f.puts @data.to_yaml }
  end

  def occurs(file)
    @data[:installed].each do |key,val| 
      return true if val.include?(file) 
    end
    return false
  end

  def archives
    archs = []
    @data[:installed].each { |key,val| archs.push(key) }
    return archs.sort
  end

  def files(archive)
    @data[:installed][archive].sort
  end

  def all_files
    all = []
    archives.each { |arch| all.concat(files(arch)) }
    return all
  end

  def all_public_files
    return self.all_files.reject { |f| !public_file?(f) }.sort
  end

  def get_packages(pattern = "*")
    # TODO: THIS IS A BAD HACK, PLEASE REMAKE WITH HIDDEN DIR AND EMPTY FILES
    # Which obviously is a hack too, but better then writing own parser ...
    list = @baseinfo.get_packages(pattern).reject { |e| !self.exists?(File.basename(e)) }
    list.collect! { |fullname| File.basename(fullname) }
    return list.sort
  end

  # TODO: Add game arch engine?
  def public_file?(filename)
    return !filename.split("/").include?("addons")
  end
end

class Package
  def initialize(fullfilename)
    @fullfilename = fullfilename
  end

  def open
    @zip = Zip::ZipFile.open(@fullfilename, "r")
  end

  def close
    @zip.close
  end

  def get_info_from_bsp
    
    return BSP.get_info(get_bsp.get_input_stream) if is_map?
    return nil
  end

  def get_files_from_zip
    @zip.entries.reject { |e| e.is_directory }.collect { |e| e.name.shift("/") }.sort
  end

  def is_map?
    !get_bsp.nil?
  end


  def get_bsp
    bsp = nil
    @zip.entries.each do |entry|
      if File.extname(entry.name) == ".bsp"
        return entry
      end
    end
    return nil
  end
  
  def get_wad_entries
    return @zip.entries.reject { |e| File.extname(e.name) != ".wad" }
  end
end

class PackageManager
  def initialize(localinfo)
    @localinfo = localinfo
  end

  def package_check(package)
    pack = Package.new(package)
    pack.open
    
    if (!pack.is_map?)
      pack.close
      return
    end

    bsp_wads, files, textures = pack.get_info_from_bsp

    #p pack.get_files_from_zip
    files.each do |file|
      file = file.downcase
      if BaseInfo.instance.include?(file)
        #puts "Found in base directory"
      elsif pack.get_files_from_zip.include?(file)
        #puts "Found in zip archive" 
      else
        #p pack.get_files_from_zip
        puts "File missing: #{file}"
      end

    end
    
    all_wads = BaseInfo.instance.wads
    
    maybe = bsp_wads.clone

    bsp_wads.each do |wad|
      if all_wads.include?(wad)
        maybe.delete(wad)
        textures -= all_wads[wad] if all_wads.include?(wad)
      end
    end

    pack.get_wad_entries.each do |entry|
      textures -= WAD.get_entries(entry.get_input_stream)
      maybe.delete(entry.name)
    end

    if textures.size > 0
      puts "Critical error: Missing textures #{textures.join(", ")}"
      puts "                The bsp map suggestes that these files are in #{maybe.join(", ")}"
    end
  end

  def remove(package)
    filelist =  @localinfo.files(package)
    filelist.each do |file| 
      if (!File.directory?(file))
        if File.exists?(file)
          puts "\tremoving #{file}"
          FileUtils.rm file
        else
          puts "\tWarning: #{file} does not exist, can't remove"
        end
        get_directories(file).sort.reverse.each do |dir|
          puts "\tdeleting directory #{dir} since empty"
          FileUtils.rmdir dir if File.exists?(dir) and dir_empty(dir)
        end
      end
    end
    @localinfo.delete(package)
    @localinfo.save
    
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      filelist.each do |file| 
        puts "\tremoving #{file} from #{@localinfo.zipfile}"
        if !outputfile.find_entry(file).nil?
          outputfile.remove(file)
        else
          puts "\tWARNING: #{@localinfo.zipfile} file does not exist in archive"
        end
      end
    end
    end
  end

  def install(filefullpath)
    filename = File.basename(filefullpath)
    raise "Package #{filename} already installed!" if @localinfo.exists?(filename)

    filelist = nil
    Zip::ZipFile.open(filefullpath) { |package| 
      # filelist = package.entries.collect { |x| x.name }
      filelist = package.entries.reject { |e| e.directory? }.collect { |x| x.name }.sort
      @localinfo.add(filename, filelist)

      # create all directories if not existend
      filelist.each { |entry| get_directories(entry).each { |dir| install_dir dir } }
      
      # TODO: sort entry names
      package.entries.each do |entry|
        if !entry.directory?
          puts "\textracting file #{entry.name}" 
          if !File.exists?(entry.name)
            entry.extract
          else
            puts "\tWARNING: file #{entry.name} already exists, omitting"
          end
        end
      end
    }
    @localinfo.save

    # modify the giant zip file
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile| 
      filelist.each do |name|
        if !@localinfo.public_file?(name)
          puts "\tomitting private file #{name}"
        else
          puts "\tadding #{name} to #{@localinfo.zipfile}"
          if outputfile.find_entry(name).nil?
            outputfile.add(name, name)
          else
            puts "\tWARNING: file #{name} in #{@localinfo.zipfile} already exists"
          end
        end
=begin
        puts "\tadding #{name} to #{@localinfo.zipfile}"
        if outputfile.find_entry(name).nil?
          outputfile.add(name, name)
        else
          puts "\tWARNING: file #{name} in #{@localinfo.zipfile} already exists"
        end
=end
      end
    end
    end
  end

  def one_less(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir[0..file_or_dir.size-base.size-2]
  end
  def one_less?(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir.size-base.size-2 > 0
  end

  def get_directories(file)
    filename = File.basename(file)
    dirname = one_less(file)

    dirs = [dirname]

    while (one_less?(dirname))
      dirname = one_less(dirname)
      dirs.push dirname
    end
    
    return dirs.sort
  end

  def install_dir(dir)
    FileUtils.mkdir(dir) if !File.directory?(dir)
  end
  
  def dir_empty(dir)
    Dir.entries(dir).join == "..."
  end


  def zipfile_iterate
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      @localinfo.all_public_files.each do |file|
        yield(outputfile, file)
      end
    end
    end
  end

  def rebase
    zipfile_iterate do |outputfile, file|
        if outputfile.find_entry(file).nil?
          puts "#{@localinfo.zipfile}: missing and adding #{file}"
          outputfile.add(file, file)
          outputfile.commit # makes it more interactive
        end
    end
  end

  def zipfile
    @localinfo.zipfile
  end

  def check
    zipfile_iterate do |outputfile, file|
      if outputfile.find_entry(file).nil?
        puts "#{file} does not exist in #{zipfile}"
      end
    end
  end

end


class CliInvoker
  public
  def initialize(klass)
    @klass = klass
    @methods = klass.public_methods - Class.public_methods
  end

  def run(args)
    name = []
    
    methods = @methods

    x = 0
    while (methods.size > 1)
      methods = collect_start(methods, ARGV[x])
      methods = trunc(methods, ARGV[x].to_s)
      name.push ARGV[x]
      
      if (methods.size == 1)
        funcname = name.join("_")
        arguments = ARGV[x+1..9999].join(" ")

        if arguments.size == 0
          evalstr = "@klass.#{funcname}"
      
        else
          evalstr = "@klass.#{funcname}(#{arguments.inspect})"
        end
        # puts evalstr
        # puts
        eval(evalstr)
        return
      end
      x += 1
    end
    puts "gelendra: did not understand you, maybe you want need some help? gelendra help"
  end

  private 
  def trunc(methods, arg)
    methods.collect { |name| name.split("_")[1...9999].join("_") }
  end

  def starts_with(fullname, startstr)
    fullname.split("_").first == startstr
  end
  
  def collect_start(methods, startstr)
    methods.reject { |func| !starts_with(func, startstr) }
  end
end


class Cli
  public
  def initialize(baseinfo, localinfo)
    @baseinfo = baseinfo
    @localinfo = localinfo
    @pm = PackageManager.new(localinfo)
    # @localinfo = localinfo
    #@manager = manager
  end

  def zip_rebase
    @pm.rebase
  end

  def zip_check
    @pm.check
  end

  def package_install(name = "*")
    @baseinfo.get_packages(name).each do |name| 
      begin
        puts
        puts "Installing #{name}"
        @pm.install(name)
      rescue => msg
        puts "\tError during installation: #{msg}"
      end
    end
  end

  def package_remove(name = "*")
    @localinfo.get_packages(name).each do |package|
      begin
        puts
        puts "Removing #{package}"
        @pm.remove(package)
      rescue => msg
        puts "Error during removing: #{msg}"
      end
    end
  end

  def package_check(name = "*")
    @baseinfo.get_packages(name).each do |package|
    begin
      puts
      puts "Checking #{package}"
      @pm.package_check(package)
    rescue => msg
      puts "Error during checking: #{msg}"
    end
    end
  end

  def package_available(name = "*")
    puts @baseinfo.get_packages(name)
  end

  def package_list(name = "*")
    puts @localinfo.get_packages(name)
  end

  def basedir_add(dir)
    if File.directory?(dir)
      dir = File.expand_path(dir)
      if !@baseinfo.base_dir.include?(dir)
        @baseinfo.base_dir.push File.expand_path(dir)
        @baseinfo.save
      else
        puts "Directory already in basedir path: #{dir}"
      end
    else
      puts "No such directory: #{dir}"
    end
  end

  def basedir_rem(dir)
    dir = File.expand_path(dir)
    
    if @baseinfo.base_dir.include?(dir)
      @baseinfo.base_dir.delete(dir)
      @baseinfo.save
      puts "basedir removed: #{dir}"
    else
      puts "No such directory in database: #{dir}"
    end
  end

  def basedir_list
    puts "Base directories remembered:\n"
    puts
    puts @baseinfo.base_dir
    puts
  end

  alias :list_packages :package_list

  def list_files
    puts @localinfo.all_files
  end

  def list_installedpackages(pattern = "*")
    puts @baseinfo.get_packages(pattern)
    puts @localinfo.get_packages(pattern)
  end
  
  def list_availablepackages(pattern = "*")
    puts @baseinfo.get_packages(pattern)
  end

  # TODO: Add game arch engine?
  def list_allmaps
    puts mapify(allmaps)
  end

  def list_installedmaps
    puts mapify(allmaps.reject { |m| !@localinfo.all_files.include?(m)})
  end

  def list_basemaps    
    puts mapify(allmaps.reject { |m| @localinfo.all_files.include?(m)})
  end

  # TODO: add zip checking 

  def database_fix
    @localinfo.archives.each do |archive|
      @localinfo.files(archive).each do |file|
        if !File.exists?(file)
          puts "#{file} does not exist though it occures in database, deleting"
          @localinfo.delete(archive, file)
        end

        if File.directory?(file)
          puts "#{file} is actually a directory, removing from database"
          @localinfo.delete(archive, file)
        end
      end
    end
    @localinfo.save
  end

  def database_check
    @localinfo.archives.each do |archive|
      @localinfo.files(archive).each do |file|
        puts "#{file} does not exist though it occures in database" if !File.exists?(file)
        puts "#{file} is a actually a directory" if File.directory?(file)
      end
    end
  end

=begin
  def softlink_base(basedir, pattern = "*")
    # TODO: rewrite localinfo
    puts pattern
    @localinfo.get_packages(pattern).each do |package|
      puts @localinfo.files(package)
    end
  end

  def softlink_rebase

  end
=end

  def help
    puts <<HELPSTRING
Copyright (C) 2010 Andrius Bentkus
This program comes with ABSOLUTELY NO WARRANTY; 
This is free software, and you are welcome to redistribute it
under certain conditions; read the file 'LICENSE' for further details

  basedir add <directory>
    remembers a directory, where it will look for packages

  basedir rem <directory>
    removes a basedir directory

  basedir list
    lists all added basedirs

  package install <pattern|package>
    extracts a package in the current directory and puts all the data to the local database
    or all packages matching the pattern

  package remove <pattern|package>
    removes the extracted package files, or all packages matching the pattern

  package list <pattern>
    lists all locally installed packages using the pattern, if no pattern provided, all packages are listed

  package available <pattern>
    lists all available packages using the pattern, if no pattern provided, all are listed

  list allmaps
    lists all installed maps

  list availablepackages
    lists all available packages in basedirectories

  list basemaps
    lists maps that were installed without gelendra

  list installedmaps
    lists all maps that were installed using gelendra

  list installedpackages
    lists locally installed packages
  
  list packages <pattern>
    lists all locally installed packages using the pattern, if not pattern provided, all are listed

  database check
    checks the local database for any errors (occuring directories, missing files)

  database fix
    removes occuring directories from database
    removes files which are missing in database
    removes database entries of files which are not present

  zip check
    checks if all installed files are in the zip file specified in database

  zip rebase
    adds missing files to the zip file specified in database

  help
    prints this help
  
HELPSTRING
  end

  private
   
  def mapify(maps)
    maps.collect do |i|
      f = File.basename(i) 
      f = f.split(".")
      f.pop
      f = f.join(".")
      f
    end
  end

  def allmaps
    Dir["cstrike/maps/*.bsp"].sort
  end

end

baseinfo = BaseInfo.instance
cli = Cli.new(BaseInfo.instance, LocalInfo.new(baseinfo));
cliinvoker = CliInvoker.new(cli)
cliinvoker.run(ARGV)
