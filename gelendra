#!/usr/bin/ruby
=begin
    gelendra is a package(archive) manager for managing counterstrike 1.6 maps, addons, etc.
    Copyright (C) 2010  Andrius Bentkus

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
=end
require 'yaml'
require 'rubygems'
require 'zip/zip'
require 'etc'
require 'fileutils'

# TODO: Manage occurences in different archives (ALLOW THEM! if files are equal)
# TODO: Check if the files in the archives are all in small letters
# TODO: Support different archives, create OOP archive control
# TODO: Directive to copy all files logged in database to another directory
# TODO: Add copy functionality
# TODO: Add softlinking
# TODO: Add central mangagement of installs
# TODO: Add independent game architecture (list maps of other games, pick only public files)

class BaseInfo
  BASEINFOFILE = "#{Etc.getpwuid.dir}/.gelendra.yaml"

  def initialize
    File.open(BASEINFOFILE, "a+") do |f|
      @data = YAML::load(f.read)
      @data = {"base_dir"=>[]} if @data == false
    end
  end

  def base_dir
    @data["base_dir"]
  end

  def save
    File.open(BASEINFOFILE, "w") { |f| f.puts @data.to_yaml }
  end

  def get_packages(pattern = "*")
    pkg = []
    base_dir.each do |dir|
      pkg.concat Dir["#{dir}/#{pattern}"]
    end
    return pkg.sort
  end
end


class LocalInfo
  # TODO: Rewrite so it will open the file only if really needed (when data invoked)
  def initialize(baseinfo, file = 'database.yaml')
    @baseinfo = baseinfo
    begin
      File.open(file,"r") { |f| @data = YAML::load(f.read) }
    rescue
      @data = { :zipfile=> nil, :installed => { } } 
    end
    @data = { :zipfile=> nil, :installed => { } } if @data == false
  end

  def zipfile
    @data[:zipfile]
  end

  def add(archivename, list)
    @data[:installed][archivename] = list
  end

  def delete(archive, file = nil)
    if file.nil?
      @data[:installed].delete(archive)
    else
      @data[:installed][archive].delete(file)
    end
  end

  def exists?(archive)
    !@data[:installed][archive].nil?
  end

  def save(file = 'database.yaml')
     File.open(file,"w") { |f| f.puts @data.to_yaml }
  end

  def occurs(file)
    @data[:installed].each do |key,val| 
      return true if val.include?(file) 
    end
    return false
  end

  def archives
    archs = []
    @data[:installed].each { |key,val| archs.push(key) }
    return archs.sort
  end

  def files(archive)
    @data[:installed][archive].sort
  end

  def all_files
    all = []
    archives.each { |arch| all.concat(files(arch)) }
    return all
  end

  def all_public_files
    return self.all_files.reject { |f| !public_file?(f) }.sort
  end

  def get_packages(pattern = "*")
    # TODO: THIS IS A BAD HACK, PLEASE REMAKE WITH HIDDEN DIR AND EMPTY FILES
    # Which obviously is a hack too, but better then writing own parser ...
    list = @baseinfo.get_packages(pattern).reject { |e| !self.exists?(File.basename(e)) }
    list.collect! { |fullname| File.basename(fullname) }
    return list.sort
  end

  # TODO: Add game arch engine?
  def public_file?(filename)
    return !filename.split("/").include?("addons")
  end
end


class PackageManager
  def initialize(localinfo)
    @localinfo = localinfo
  end

  def remove(package)

    filelist =  @localinfo.files(package)
    filelist.each do |file| 
      if (!File.directory?(file))
        if File.exists?(file)
          puts "\tremoving #{file}"
          FileUtils.rm file
        else
          puts "\tWarning: #{file} does not exist, can't remove"
        end
        get_directories(file).sort.reverse.each do |dir|
          puts "\tdeleting directory #{dir} since empty"
          FileUtils.rmdir dir if File.exists?(dir) and dir_empty(dir)
        end
      end
    end
    @localinfo.delete(package)
    @localinfo.save
    
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      filelist.each do |file| 
        puts "\tremoving #{file} from #{@localinfo.zipfile}"
        if !outputfile.find_entry(file).nil?
          outputfile.remove(file)
        else
          puts "\tWARNING: #{@localinfo.zipfile} file does not exist in archive"
        end
      end
    end
    end
  end

  def install(filefullpath)
    filename = File.basename(filefullpath)
    raise "Package #{filename} already installed!" if @localinfo.exists?(filename)

    filelist = nil
    Zip::ZipFile.open(filefullpath) { |package| 
      # filelist = package.entries.collect { |x| x.name }
      filelist = package.entries.reject { |e| e.directory? }.collect { |x| x.name }.sort
      @localinfo.add(filename, filelist)

      # create all directories if not existend
      filelist.each { |entry| get_directories(entry).each { |dir| install_dir dir } }
      
      # TODO: sort entry names
      package.entries.each do |entry|
        if !entry.directory?
          puts "\textracting file #{entry.name}" 
          if !File.exists?(entry.name)
            entry.extract
          else
            puts "\tWARNING: file #{entry.name} already exists, omitting"
          end
        end
      end
    }
    @localinfo.save

    # modify the giant zip file
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile| 
      filelist.each do |name|
        if !@localinfo.public_file?(name)
          puts "\tomitting private file #{name}"
        else
          puts "\tadding #{name} to #{@localinfo.zipfile}"
          if outputfile.find_entry(name).nil?
            outputfile.add(name, name)
          else
            puts "\tWARNING: file #{name} in #{@localinfo.zipfile} already exists"
          end
        end
=begin
        puts "\tadding #{name} to #{@localinfo.zipfile}"
        if outputfile.find_entry(name).nil?
          outputfile.add(name, name)
        else
          puts "\tWARNING: file #{name} in #{@localinfo.zipfile} already exists"
        end
=end
      end
    end
    end
  end

  def one_less(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir[0..file_or_dir.size-base.size-2]
  end
  def one_less?(file_or_dir)
    base = File.basename(file_or_dir)
    return file_or_dir.size-base.size-2 > 0
  end

  def get_directories(file)
    filename = File.basename(file)
    dirname = one_less(file)

    dirs = [dirname]

    while (one_less?(dirname))
      dirname = one_less(dirname)
      dirs.push dirname
    end
    
    return dirs.sort
  end

  def install_dir(dir)
    FileUtils.mkdir(dir) if !File.directory?(dir)
  end
  
  def dir_empty(dir)
    Dir.entries(dir).join == "..."
  end


  def zipfile_iterate
    if !@localinfo.zipfile.nil?
    Zip::ZipFile.open(@localinfo.zipfile, "wb") do |outputfile|
      @localinfo.all_public_files.each do |file|
        yield(outputfile, file)
      end
    end
    end
  end

  def rebase
    zipfile_iterate do |outputfile, file|
        if outputfile.find_entry(file).nil?
          puts "#{@localinfo.zipfile}: missing and adding #{file}"
          outputfile.add(file, file)
          outputfile.commit # makes it more interactive
        end
    end
  end

  def zipfile
    @localinfo.zipfile
  end

  def check
    zipfile_iterate do |outputfile, file|
      if outputfile.find_entry(file).nil?
        puts "#{file} does not exist in #{zipfile}"
      end
    end
  end
end


class CliInvoker
  public
  def initialize(klass)
    @klass = klass
    @methods = klass.public_methods - Class.public_methods
  end

  def run(args)
    name = []
    
    methods = @methods

    x = 0
    while (methods.size > 1)
      methods = collect_start(methods, ARGV[x])
      methods = trunc(methods, ARGV[x].to_s)
      name.push ARGV[x]
      
      if (methods.size == 1)
        funcname = name.join("_")
        arguments = ARGV[x+1..9999].join(" ")

        if arguments.size == 0
          evalstr = "@klass.#{funcname}"
      
        else
          evalstr = "@klass.#{funcname}(#{arguments.inspect})"
        end
        # puts evalstr
        # puts
        eval(evalstr)
        return
      end
      x += 1
    end
  end

  private 
  def trunc(methods, arg)
    methods.collect { |name| name.split("_")[1...9999].join("_") }
  end

  def starts_with(fullname, startstr)
    fullname.split("_").first == startstr
  end
  
  def collect_start(methods, startstr)
    methods.reject { |func| !starts_with(func, startstr) }
  end
end


class Cli
  public
  def initialize(baseinfo, localinfo)
    @baseinfo = baseinfo
    @localinfo = localinfo
    @pm = PackageManager.new(localinfo)
    # @localinfo = localinfo
    #@manager = manager
  end

  def zip_rebase
    @pm.rebase
  end

  def zip_check
    @pm.check
  end

  def package_install(name)
    @baseinfo.get_packages(name).each do |name| 
      begin
        puts
        puts "Installing #{name}"
        @pm.install(name)
      rescue => msg
        puts "\tError during installation: #{msg}"
      end
    end
  end

  def package_remove(name)
    @localinfo.get_packages.each do |package|
      begin
        puts
        puts "Removing #{package}"
        @pm.remove(package)
      rescue => msg
        puts "Error during removing: #{msg}"
      end
    end
  end

  def package_available(name = "*")
    puts @baseinfo.get_packages(name)
  end

  def package_list(name = "*")
    puts @localinfo.get_packages(name)
  end

  def basedir_add(dir)
    if File.directory?(dir)
      dir = File.expand_path(dir)
      if !@baseinfo.base_dir.include?(dir)
        @baseinfo.base_dir.push File.expand_path(dir)
        @baseinfo.save
      else
        puts "Directory already in basedir path: #{dir}"
      end
    else
      puts "No such directory: #{dir}"
    end
  end

  def basedir_rem(dir)
    dir = File.expand_path(dir)
    
    if @baseinfo.base_dir.include?(dir)
      @baseinfo.base_dir.delete(dir)
      @baseinfo.save
      puts "basedir removed: #{dir}"
    else
      puts "No such directory in database: #{dir}"
    end
  end

  def basedir_list
    puts "Base directories remembered:\n"
    puts
    puts @baseinfo.base_dir
    puts
  end

  def list_packages(name = "*")
    package_list(name)
  end

  def list_files
    puts @localinfo.all_files
  end

  def list_installedpackages(pattern = "*")
    puts @baseinfo.get_packages(pattern)
    puts @localinfo.get_packages(pattern)
  end
  
  def list_availablepackages(pattern = "*")
    puts @baseinfo.get_packages(pattern)
  end

  # TODO: Add game arch engine?
  def list_allmaps
    puts mapify(allmaps)
  end

  def list_installedmaps
    puts mapify(allmaps.reject { |m| !@localinfo.all_files.include?(m)})
  end

  def list_basemaps    
    puts mapify(allmaps.reject { |m| @localinfo.all_files.include?(m)})
  end

  # TODO: add zip checking 

  def database_fix
    @localinfo.archives.each do |archive|
      @localinfo.files(archive).each do |file|
        if !File.exists?(file)
          puts "#{file} does not exist though it occures in database, deleting"
          @localinfo.delete(archive, file)
        end

        if File.directory?(file)
          puts "#{file} is actually a directory, removing from database"
          @localinfo.delete(archive, file)
        end
      end
    end
    @localinfo.save
  end

  def database_check
    @localinfo.archives.each do |archive|
      @localinfo.files(archive).each do |file|
        puts "#{file} does not exist though it occures in database" if !File.exists?(file)
        puts "#{file} is a actually a directory" if File.directory?(file)
      end
    end
  end

  def help
    puts <<HELPSTRING
Copyright (C) 2010 Andrius Bentkus
This program comes with ABSOLUTELY NO WARRANTY; 
This is free software, and you are welcome to redistribute it
under certain conditions; read the file 'LICENSE' for further details

  basedir add <directory>
    remembers a directory, where it will look for packages

  basedir rem <directory>
    removes a basedir directory

  basedir list
    lists all added basedirs

  package install <package>
    extracts package in the current directory and puts all the data to the local database

  package remove <package>
    removes the extracted package files

  package list <pattern>
    lists all locally installed packages using the pattern, if not pattern provided, all are listed

  package available <pattern>
    lists all available packages using the pattern, if no pattern provided, all are listed

  zip check
    checks if all installed files are in the zip file specified in database

  zip rebase
    adds missing files to the zip file specified in database

  list availablepackages
    lists all available packages in basedirectories

  list installedpackages
    lists locally installed packages
  
  list allmaps
    lists all installed maps

  list installedmaps
    lists all maps that were installed using gelendra

  list basemaps
    lists maps that were installed without gelendra

  database check
    checks the local database for any errors (occuring directories, missing files)

  database fix
    removes occuring directories from database
    removes files which are missing in database
    removes database entries of files which are not present

  help
    prints this help
  
HELPSTRING
  end

  private
   
  def mapify(maps)
    maps.collect do |i|
      f = File.basename(i) 
      f = f.split(".")
      f.pop
      f = f.join(".")
      f
    end
  end

  def allmaps
    Dir["cstrike/maps/*.bsp"].sort
  end

end

baseinfo = BaseInfo.new
cli = Cli.new(BaseInfo.new, LocalInfo.new(baseinfo));
cliinvoker = CliInvoker.new(cli)
cliinvoker.run(ARGV)
